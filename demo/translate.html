<!doctype html>
<html>
<head>
<title>glsl-simulator: manual input</title>
<link rel="stylesheet" href="lib/codemirror.css" />
<link rel="stylesheet" href="assets/shared.css" />
<script src="../browser/glsl-simulator-0.1.0.js"></script>
<script src="lib/codemirror.js"></script>
<script src="lib/jsDump.js"></script>
<script src="lib/mode/glsl.js"></script>

<style type="text/css">
.inverted {
    filter: invert(0%);
    -webkit-filter: invert(0%);
}
</style>

</head>
<body>
    <form>
<div id="demo-container">
<div id="left-side">
    <div id="demo-header">
    GLSL Simulator Demo: Single Execution
    </div>
</div>
<div id="right-side"></div>
</form>
</div>

<script type="x-glsl-vshader" id="sample-vertex-shader">
attribute vec2 position;

void main()
{
    gl_Position = vec4(position, 0.0, 1.0);
}
</script>
<script type="x-glsl-fshader" id="sample-fragment-shader">
// Sample shader from: http://glslsandbox.com/e#21330.5

/* Here's a block
comment for you.
*/

#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
uniform vec4 color;

// b/w remix
// tomaes.32x.de 2014.11
void main( void ) {

    vec3 col = vec3(0.1,0.2,0.3);
    vec2 pos = ( gl_FragCoord.xy / resolution.xy );

    float sd = 0.19 - (pos.y*0.004 / pos.x*0.5) - atan( pos.x + pos.y, 40.0 );
    float so = 0.22 + pos.y*0.0003/pos.x*(0.15 + sin(time*0.04+pos.x*3.5));

    float t = mod(time*0.1, 2.0) + 440.0;
    float x = mod(pos.x + t, so);
    float y = mod(pos.y + t, so*2.0);
    float d1 = mod( distance( vec2(x,y), vec2(so*0.45,so*1.05) ) + t*0.5, 0.05) * 3.0 + pos.x * 0.5;
    float d2 = mod( distance( vec2(x,y), vec2(so*0.55,so*0.95) ) + t*0.5, 0.015) * 3.0;

    if ((x-0.03 < sd) && (y-0.03 < sd*2.0))
    if ((x < sd) && (y < sd*2.0))
        col = vec3(0.2, 0.6, mix(d1, d2, 0.8) );
    else
        col = vec3(0.72, 0.25, pos.y * 0.06 + 0.3);


    float l = length(mod(t* 0.1 + col * distance(pos,vec2(pos.y,0.0)) ,0.02)*27.5); 

    if ((pos.y>0.1) && (pos.y < 0.9))
        gl_FragColor = vec4( l,l,l, 1.0 );
    else
        gl_FragColor = vec4( 0.9,0.9,0.9, 1.0);
}
</script>

<script type="text/javascript">

var DemoModel = function()
{
    this._program = new GLSL.Program;
    // Map from "name_type" to previous GLSL value.
    this._previousInputs = {};

    this._resetEnvironment();
};

DemoModel.Event = {
    ShaderChanged: "demo-model-shader-changed",
    InputsChanged: "demo-model-inputs-changed",
    ResultChanged: "demo-model-result-changed",
    Error: "demo-model-error"
};

DemoModel.prototype = {
    __proto__: GLSL.Object.prototype,
    constructor: DemoModel,

    // Public

    updateShaderWithType: function(shaderType, text)
    {
        try {
            var oldShader = this._program.shaderWithType(shaderType);
            if (oldShader)
                oldShader.removeEventListener(GLSL.Shader.Event.ExecutableChanged, this._shaderExecutableChanged, this);

            var newShader = new GLSL.Shader(text, shaderType);
            newShader.addEventListener(GLSL.Shader.Event.ExecutableChanged, this._shaderExecutableChanged, this);
            this._program.insertShader(newShader);
        } catch (e) {
            this.dispatchEventToListeners(DemoModel.Event.Error, {type: e.type, message: e.message});
            return;
        }

        this._resetEnvironment();

        this.dispatchEventToListeners(DemoModel.Event.ShaderChanged, {oldShader: oldShader, shader: newShader});

        this._runShaders();
    },

    shaderWithType: function(shaderType)
    {
        return this._program.shaderWithType(shaderType);
    },

    getSuggestedVariableValue: function(variable)
    {
        if (!variable || variable.readOnly)
            return null;

        var key = [variable.name, variable.type].join("_");
        if (key in this._previousInputs)
            return this._previousInputs[key];

        return null;
    },

    setVariableValue: function(variable, value)
    {
        this.env.set(variable.name, value);
        var key = [variable.name, variable.type].join("_");
        this._previousInputs[key] = value;
        this.dispatchEventToListeners(DemoModel.Event.InputsChanged, {variable: variable});

        this._runShaders();
    },

    // Private

    _resetEnvironment: function()
    {
        var model = this;

        function setDefaultValue(env, variable) {
            var value = model.getSuggestedVariableValue(variable) || 0.0;
            if (!value) {
                switch (variable.type) {
                case "bool": value = true; break;
                case "vec2": value = GLSL.Runtime.Vec2(0, 0); break;
                case "vec3": value = GLSL.Runtime.Vec3(0, 0, 0); break;
                case "vec4": value = GLSL.Runtime.Vec4(0, 0, 0, 0); break;
                case "mat2": value = GLSL.Runtime.Mat2(0, 0,
                                                       0 ,0); break;
                case "mat3": value = GLSL.Runtime.Mat3(0, 0, 0,
                                                       0, 0, 0,
                                                       0, 0, 0); break;
                case "mat4": value = GLSL.Runtime.Mat4(0, 0, 0, 0,
                                                       0, 0, 0, 0,
                                                       0, 0, 0, 0,
                                                       0, 0, 0, 0); break;
                }
            }

            env.set(variable.name, value);
        }

        function setDefaultValuesForShader(shader, env) {
            if (!shader)
                return;

            shader.uniforms.map(setDefaultValue.bind(null, env));
            shader.attributes.map(setDefaultValue.bind(null, env));
            if (shader.type === GLSL.Shader.Type.Fragment)
                shader.varyings.map(setDefaultValue.bind(null, env));
        }

        this.env = new GLSL.Environment;
        setDefaultValuesForShader(this.shaderWithType(GLSL.Shader.Type.Vertex), this.env);
        setDefaultValuesForShader(this.shaderWithType(GLSL.Shader.Type.Fragment), this.env);

    },

    _runShaders: function()
    {
        function invokeShaderOrFail(shader) {
            if (!shader)
                return true;

            if (shader.executable.error) {
                var errorType = (shader.type === GLSL.Shader.Type.Vertex) ? GLSL.Error.Type.VertexShaderTranslation : GLSL.Error.Type.FragmentShaderTranslation;
                var data = {type: errorType, message: shader.executable.error};
                this.dispatchEventToListeners(DemoModel.Event.Error, data);
                return false;
            }

            try {
                shader.executable.code.call(null, GLSL, this.env);
            } catch (e) {
                var errorType = (shader.type === GLSL.Shader.Type.Vertex) ? GLSL.Error.Type.VertexShaderExecution : GLSL.Error.Type.FragmentShaderExecution;
                this.dispatchEventToListeners(DemoModel.Event.Error, {type: errorType, message: e.message});
                return false;
            }

            return true;
        }

        var vertexShader = this.shaderWithType(GLSL.Shader.Type.Vertex);
        if (!invokeShaderOrFail.call(this, vertexShader))
            return;

        var fragmentShader = this.shaderWithType(GLSL.Shader.Type.Fragment);
        if (!invokeShaderOrFail.call(this, fragmentShader))
            return;

        this.dispatchEventToListeners(DemoModel.Event.ResultChanged);
    },

    _shaderExecutableChanged: function(event)
    {
        this._runShaders();
    }
};

var OutputView = function(model, which) {
    console.assert(model instanceof DemoModel);
    this.model = model;

    this._errorSources = {};
    this._errorSources[GLSL.Error.Type.VertexShaderParsing] = "Vertex Shader Parsing Problem:";
    this._errorSources[GLSL.Error.Type.FragmentShaderParsing] = "Fragment Shader Parsing Problem:";
    this._errorSources[GLSL.Error.Type.VertexShaderTranslation] = "Vertex Shader Translation Problem:";
    this._errorSources[GLSL.Error.Type.FragmentShaderTranslation] = "Fragment Shader Translation Problem:";
    this._errorSources[GLSL.Error.Type.VertexShaderExecution] = "Vertex Shader Execution Problem:";
    this._errorSources[GLSL.Error.Type.FragmentShaderExecution] = "Fragment Shader Execution Problem:";

    this.element = document.createElement("div");
    this.element.classList.add("results-viewer");
    this.element.id = "results-" + which;

    var optionsContainer = document.createElement("span");
        optionsContainer.classList.add("output-options");
    this.element.appendChild(optionsContainer);

    this.shaderSelectorElement = document.createElement("select");
        this.shaderSelectorElement.id = "results-" + which + "-shader-selector";
        var option = null;
        option = document.createElement("option");
            option.text = "Vertex Shader";
            option.value = GLSL.Shader.Type.Vertex;
        this.shaderSelectorElement.add(option, null);

        option = document.createElement("option");
            option.text = "Fragment Shader";
            option.value = GLSL.Shader.Type.Fragment;
        this.shaderSelectorElement.add(option, null);
    optionsContainer.appendChild(this.shaderSelectorElement);

    this.outputSelectorElement = document.createElement("select");
        this.outputSelectorElement.id = "results-" + which + "-output-selector";
        option = document.createElement("option");
            option.text = "Shader AST";
            option.value = "ast";
        this.outputSelectorElement.add(option, null);

        option = document.createElement("option");
            option.text = "Pretty Printer";
            option.value = "pretty";
        this.outputSelectorElement.add(option, null);

        option = document.createElement("option");
            option.text = "Generated JavaScript";
            option.value = "codegen";
        this.outputSelectorElement.add(option, null);

        option = document.createElement("option");
            option.text = "Primary Output";
            option.value = "output";
        this.outputSelectorElement.add(option, null);
        optionsContainer.appendChild(this.outputSelectorElement);

    this.outputElement = document.createElement("span");
        this.outputElement.classList.add("output");
    this.element.appendChild(this.outputElement);


    this.shaderSelectorElement.addEventListener("change", this.refresh.bind(this));
    this.outputSelectorElement.addEventListener("change", this.refresh.bind(this));
    this.model.addEventListener(DemoModel.Event.ShaderChanged, this.refresh, this);
    this.model.addEventListener(DemoModel.Event.ResultChanged, this.refresh, this);
};

OutputView.prototype = {
    constructor: OutputView,
    __proto__: GLSL.Object.prototype,

    get activeShaderType()
    {
        return this.shaderSelectorElement.options[this.shaderSelectorElement.selectedIndex].value;
    },

    set activeShaderType(value)
    {
        var options = this.shaderSelectorElement.options;
        for (var i = 0; i < options.length; ++i)
            if (value === options[i].value)
                options[i].selected = true;

        this.refresh();
    },

    get activeOutputType()
    {
        return this.outputSelectorElement.options[this.outputSelectorElement.selectedIndex].value;
    },

    set activeOutputType(value)
    {
        var options = this.outputSelectorElement.options;
        for (var i = 0; i < options.length; ++i)
            if (value === options[i].value)
                options[i].selected = true;

        this.refresh();
    },

    showErrorMessage: function(type, message)
    {
        if (this.outputElement) {
            this.element.removeChild(this.outputElement);
            delete this.outputElement;
        }

        this.outputElement = document.createElement("span");
            this.element.classList.add("error-message");
            this.outputElement.classList.add("output");
            this.outputElement.textContent = (this._errorSources[type] || "Error:") + "\n" + message;
        this.element.appendChild(this.outputElement);
    },

    refresh: function()
    {
        if (this.outputElement) {
            this.element.removeChild(this.outputElement);
            delete this.outputElement;
        }

        var shader = this.model.shaderWithType(this.activeShaderType);
        if (!shader)
            return;

        this.outputElement = document.createElement("span");
            this.outputElement.classList.add("output");
        this.element.appendChild(this.outputElement);
        this.element.classList.remove("error-message");

        switch (this.activeOutputType) {
        case "ast":
            this.outputElement.appendChild(document.createTextNode(jsDump.parse(shader.ast)));
        break;

        case "codegen":
            var source = shader.executable.source || shader.executable.code.toString();
            this.outputElement.appendChild(document.createTextNode(source));
        break;

        case "output":
            if (this.activeShaderType === GLSL.Shader.Type.Fragment) {
                var rawColor = this.model.env.get('gl_FragColor');
                if (!rawColor)
                    break;

                var color = GLSL.Runtime.clamp(this.model.env.get('gl_FragColor'), 0.0, 1.0);
                var hex = GLSL.Runtime.floor(color.get("rgb").multiply(255.0));
                var colorString = "rgba(" + [hex.get('r'), hex.get('g'), hex.get('b'), color.get('a')].join(", ") + ")";
                var vectorString = [rawColor.get("r"), rawColor.get("g"), rawColor.get("b"), rawColor.get("a")].join(", ");
                this.outputElement.style.backgroundColor = colorString;
                var text = this.outputElement.appendChild(document.createElement("span"));
                text.classList.add("inverted");
                text.textContent = "gl_FragColor = [" + vectorString + "]\n\n(color: " + colorString + ")";
            }

            if (this.activeShaderType === GLSL.Shader.Type.Vertex) {
                var position = this.model.env.get('gl_Position');
                var pointSize = this.model.env.get('gl_PointSize');

                if (!position && !pointSize)
                    break;

                var output = "";
                if (position) {
                    var positionString = [position.get("x"), position.get("y"), position.get("z"), position.get("w")].join(", ");
                    output += "gl_Position = [" + positionString + "]\n";
                }
                if (pointSize)
                    output += "gl_PointSize = " + pointSize;

                this.outputElement.textContent = output;
            }
        break;

        case "pretty":
        default:
            var printer = new GLSL.PrettyPrinter();
            this.outputElement.appendChild(document.createTextNode(printer.formattedText(shader.ast)));
        break;
        }
    }
}

var EditorView = function(model) {
    this.model = model;

    this.element = document.createElement("div");
    this.element.classList.add("shader-editor");

    var item = null;

    this.optionsElement = document.createElement("span");
        this.optionsElement.classList.add("editor-options");
        var optionsList = this.optionsElement.appendChild(document.createElement("ul"));
        this.selectorElement = document.createElement("select");
            this.selectorElement.id = "editor-selector";
            var option = null;
                option = document.createElement("option");
                option.text = "Vertex Shader";
                option.value = GLSL.Shader.Type.Vertex;
            this.selectorElement.add(option, null);

            option = document.createElement("option");
                option.text = "Fragment Shader";
                option.value = GLSL.Shader.Type.Fragment;
            this.selectorElement.add(option, null);
            item = optionsList.appendChild(document.createElement("li"));
        item.appendChild(this.selectorElement);
        var checkboxLabel = document.createElement("label");
            this.emitDebuggerCheckbox = document.createElement("input");
                this.emitDebuggerCheckbox.type = "checkbox";
            checkboxLabel.textContent = "Pause Inside Shader";
            checkboxLabel.appendChild(this.emitDebuggerCheckbox);
            item = optionsList.appendChild(document.createElement("li"));
        item.appendChild(checkboxLabel);
    this.element.appendChild(this.optionsElement);

    // Select the fragment shader by default.
    this.selectorElement.options[1].selected = true;
    this.selectorElement.addEventListener("change", this._shaderSelectorChanged.bind(this));

    var editorStub = document.createElement("div");
        editorStub.id = "shader-editor-stub";
    this.element.appendChild(editorStub);

    // Set up CodeMirror to replace the editor stub.
    this._cm = CodeMirror(function(editorNode) {
        editorStub.parentNode.replaceChild(editorNode, editorStub);
        editorNode.id = editorStub.id;
        editorNode.classList.add("stub");
    }, {
        value: "",
        mode: "glsl",
        lineNumbers: true
    });

    this._cm.on("changes", this._shaderEditorContentChanged.bind(this));
    this.emitDebuggerCheckbox.addEventListener("change", this._emitDebuggerCheckboxChanged.bind(this));
};

EditorView.Event = {
    ShaderTypeChanged: "editor-view-shader-type-changed"
};

EditorView.prototype = {
    constructor: EditorView,
    __proto__: GLSL.Object.prototype,

    // Public

    get activeShaderType()
    {
        return this.selectorElement.options[this.selectorElement.selectedIndex].value;
    },

    set activeShaderType(value)
    {
        var options = this.selectorElement.options;
        for (var i = 0; i < options.length; ++i)
            if (value === options[i].value)
                options[i].selected = true;

        this.refresh();
    },

    refresh: function()
    {
        this.autosizeHeight();

        var selectedShader = this.model.shaderWithType(this.activeShaderType);
        this._cm.setValue(selectedShader ? selectedShader.sourceText : "");
    },

    autosizeHeight: function()
    {
        var allowedHeight = this.element.offsetHeight - 5 + "px";
        document.getElementById("shader-editor-stub").style.height = allowedHeight;
    },

    // Private

    _shaderSelectorChanged: function(event)
    {
        console.assert(event.target === this.selectorElement, event.target);
        console.assert(event.target.selectedIndex != -1, event.target);

        this.refresh();
        this.dispatchEventToListeners(EditorView.Event.ShaderTypeChanged, this.activeShaderType);
    },

    _shaderEditorContentChanged: function(event)
    {
        this.model.updateShaderWithType(this.activeShaderType, this._cm.getValue());
    },

    _emitDebuggerCheckboxChanged: function(event)
    {
        var activeShader = this.model.shaderWithType(this.activeShaderType);
        activeShader.shouldEmitDebuggerStatement = !!this.emitDebuggerCheckbox.checked;
    },
};

var VariableView = function(variable, suggestedValue) {
    this.variable = variable;

    this._fields = [];

    var variableRow = this.element = document.createElement("div");
    variableRow.classList.add("variable-row", variable.usage);

    var usageLabel = variableRow.appendChild(document.createElement("span"));
    usageLabel.classList.add("variable-usage", variable.usage);
    usageLabel.textContent = variable.usage;

    var qualifierLabel = variableRow.appendChild(document.createElement("span"));
    qualifierLabel.classList.add("variable-qualifier", variable.qualifier);
    qualifierLabel.textContent = variable.qualifier;

    var label = variableRow.appendChild(document.createElement("span"));
    label.classList.add("variable-label");
    if (variable.builtin)
        label.classList.add("builtin");
    label.textContent = variable.name;

    var typeLabel = variableRow.appendChild(document.createElement("span"));
    typeLabel.classList.add(variable.type, "variable-type");
    typeLabel.textContent = variable.type;

    // TODO: handle sampler2D and samplerCube seperately, by adding a
    // file upload widget and thumbnail preview.

    var cellTable = variableRow.appendChild(document.createElement("table"));
    cellTable.classList.add("variable-cells");

    var rowCount = 1;
    var colCount = 1;

    switch (variable.type) {
    case "float": break;
    case "vec2":  colCount = 2; break;
    case "vec3":  colCount = 3; break;
    case "vec4":  colCount = 4; break;
    case "mat2":  colCount = 2; rowCount = 2; break;
    case "mat3":  colCount = 3; rowCount = 3; break;
    case "mat4":  colCount = 4; rowCount = 4; break;
    default: break;
    }

    for (var i = 0; i < rowCount; ++i) {
        var row = document.createElement("tr");
        for (var j = 0; j < colCount; ++j) {
            var cell = document.createElement("td");
            if (j == 0)
                cell.appendChild(document.createTextNode(i == 0 && colCount > 1 ? "[" : "\u00A0"));

            var input = cell.appendChild(document.createElement("input"));
            input.type = "text";
            input.maxLength = 5;
            input.placeholder = "0.0";
            if (variable.usage === "out")
                input.readOnly = true;
            this._fields.push(input);
            if (j < colCount - 1)
                cell.appendChild(document.createTextNode(","));
            else if (colCount > 1 && i == rowCount - 1)
                cell.appendChild(document.createTextNode("]"))
            row.appendChild(cell);
        }

        cellTable.appendChild(row);
    }

    if (variable.usage === "in" && !!suggestedValue)
        this.insertValue(suggestedValue);

    if (variable.usage === "in")
        cellTable.addEventListener("input", this._fieldInputChanged.bind(this));
}

VariableView.Event = {
    "InputChanged": "variable-view-input-changed",
};

VariableView.prototype = {
    constructor: VariableView,
    __proto__: GLSL.Object.prototype,

    // Public

    insertValue: function(value)
    {
        var dim = 4;

        switch (this.variable.type) {
        case "float": this._fields[0].value = value; break;

        case "vec2": dim--;
        case "vec3": dim--;
        case "vec4":
            for (var i = 0; i < dim; ++i)
                this._fields[i].value = value.d[i];
            break;

        case "vec2": dim--;
        case "vec3": dim--;
        case "vec4":
            for (var i = 0; i < dim; ++i)
                for (var j = 0; j < dim; ++j)
                    this._fields[i * dim + j].value = value.d[i][j];
            break;

        default: break;
        }
    },

    extractValue: function()
    {
        var values = this._fields.map(function(f) {
            return (f.value && !f.value.endsWith(".")) ? Number(f.value) : NaN;
        });
        if (values.some(function(v) { return isNaN(v); }))
            return null;

        switch (this.variable.type) {
            case "float": return values[0];
            case "vec2": return GLSL.Runtime.Vec2.apply(null, values);
            case "vec3": return GLSL.Runtime.Vec3.apply(null, values);
            case "vec4": return GLSL.Runtime.Vec4.apply(null, values);
            case "mat2": return GLSL.Runtime.Mat2.apply(null, values);
            case "mat3": return GLSL.Runtime.Mat3.apply(null, values);
            case "mat4": return GLSL.Runtime.Mat4.apply(null, values);
        }
    },

    // Private

    _fieldInputChanged: function(event)
    {
        var cell = event.target;
        cell.classList.remove("valid-input");
        cell.classList.remove("invalid-input");

        if (cell.value.endsWith(".") || isNaN(Number(cell.value))) {
            cell.classList.add("invalid-input");
            return;
        }

        cell.classList.add("valid-input");

        if (this.extractValue() !== null) // Don't send an event unless all fields complete.
            this.dispatchEventToListeners(VariableView.Event.InputChanged);
    }
};

var VariableListView = function(model, shaderType) {
    this.model = model;
    this.shader = shaderType ? this.model.shaderWithType(shaderType) : null;

    this._variableMap = new Map;

    this.element = document.createElement("div");
    this.element.classList.add("variable-list");

    this.model.addEventListener(DemoModel.Event.ResultChanged, this._resultsChanged, this);

    if (!this.shader)
        return;

    function createVariable(variable) {
        var view = new VariableView(variable, this.model.getSuggestedVariableValue(variable));
        this._variableMap.set(variable, view);
        this.element.appendChild(view.element);

        if (!variable.readOnly)
            view.addEventListener(VariableView.Event.InputChanged, this._inputChanged, this);
    }

    this.shader.uniforms.map(createVariable.bind(this));
    if (this.shader.type === GLSL.Shader.Type.Vertex)
        this.shader.attributes.map(createVariable.bind(this));

    this.shader.varyings.map(createVariable.bind(this));
};

VariableListView.prototype = {
    constructor: VariableListView,
    __proto__: GLSL.Object.prototype,

    // Public

    willHide: function()
    {
        this.model.removeEventListener(DemoModel.Event.ResultChanged, this._resultsChanged, this);
    },

    // Private

    _inputChanged: function(event)
    {
        var variableView = event.target;
        this.model.setVariableValue(variableView.variable, variableView.extractValue());
    },

    _resultsChanged: function()
    {
        this._variableMap.forEach(function(value, key, map) {
            var variable = key, view = value;
            var storedValue = this.model.env.get(variable.name);

            if (!variable.readOnly && storedValue)
                view.insertValue(storedValue);
        }, this);
    }
};

var model = null;

window.addEventListener("load", function initEditors() {
    model = new DemoModel();

    var leftSide = document.getElementById("left-side");
    var rightSide = document.getElementById("right-side");

    var variableList = new VariableListView(model, null);
    leftSide.appendChild(variableList.element);
    var editor = new EditorView(model);
    leftSide.appendChild(editor.element);

    var resultsTop = new OutputView(model, "top");
    rightSide.appendChild(resultsTop.element);
    var resultsBottom = new OutputView(model, "bottom");
    rightSide.appendChild(resultsBottom.element);

    function recreateVariableList() {
        newList = new VariableListView(model, editor.activeShaderType);
        leftSide.replaceChild(newList.element, variableList.element);
        variableList.willHide();
        variableList = newList;
    }

    editor.addEventListener(EditorView.Event.ShaderTypeChanged, recreateVariableList);
    model.addEventListener(DemoModel.Event.ShaderChanged, recreateVariableList);
    model.addEventListener(DemoModel.Event.Error, function displayError(event) {
        var errorType = event.data.type;
        if (errorType === GLSL.Error.Type.VertexShaderTranslation || GLSL.Error.Type.VertexShaderExecution) {
            resultsBottom.activeShaderType = GLSL.Shader.Type.Vertex;
            resultsBottom.activeOutputType = "codegen";
        }

        if (errorType === GLSL.Error.Type.FragmentShaderTranslation || GLSL.Error.Type.FragmentShaderExecution) {
            resultsBottom.activeShaderType = GLSL.Shader.Type.Fragment;
            resultsBottom.activeOutputType = "codegen";
        }

        resultsTop.showErrorMessage(errorType, event.data.message);
    });

    window.addEventListener("resize", editor.autosizeHeight.bind(editor));

    model.updateShaderWithType(GLSL.Shader.Type.Vertex, document.getElementById("sample-vertex-shader").textContent);
    model.updateShaderWithType(GLSL.Shader.Type.Fragment, document.getElementById("sample-fragment-shader").textContent);
    editor.refresh();

    // Change these defaults if you want to start somewhere else.
    editor.activeShaderType = GLSL.Shader.Type.Vertex;

    resultsTop.activeShaderType = GLSL.Shader.Type.Vertex;
    resultsTop.activeOutputType = "codegen";

    resultsBottom.activeShaderType = GLSL.Shader.Type.Vertex;
    resultsBottom.activeOutputType = "ast";
});

</script>

</body>
</html>
