<!doctype html>
<html>
<head>
<title>glsl-simulator: manual input</title>
<link rel="stylesheet" href="external/codemirror.css" />
<link rel="stylesheet" href="assets/shared.css" />
<script src="../browser/glsl-simulator-0.1.0.js"></script>
<script src="external/codemirror.js"></script>
<script src="external/jsDump.js"></script>
<script src="external/mode/glsl.js"></script>
<script src="lib/DebugView.js"></script>
<script src="lib/EditorView.js"></script>
<script src="lib/VariableView.js"></script>

<style type="text/css">
.inverted {
    filter: invert(0%);
    -webkit-filter: invert(0%);
}
</style>

</head>
<body>
    <form>
<div id="demo-container">
<div id="left-side">
    <div id="demo-header">
    GLSL Simulator Demo: Single Execution
    </div>
</div>
<div id="right-side"></div>
</form>
</div>

<script type="x-glsl-vshader" id="sample-vertex-shader">
attribute vec2 position;

void main()
{
    gl_Position = vec4(position, 0.0, 1.0);
}
</script>
<script type="x-glsl-fshader" id="sample-fragment-shader">
// Sample shader from: http://glslsandbox.com/e#21330.5

/* Here's a block
comment for you.
*/

#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
uniform vec4 color;

// b/w remix
// tomaes.32x.de 2014.11
void main( void ) {

    vec3 col = vec3(0.1,0.2,0.3);
    vec2 pos = ( gl_FragCoord.xy / resolution.xy );

    float sd = 0.19 - (pos.y*0.004 / pos.x*0.5) - atan( pos.x + pos.y, 40.0 );
    float so = 0.22 + pos.y*0.0003/pos.x*(0.15 + sin(time*0.04+pos.x*3.5));

    float t = mod(time*0.1, 2.0) + 440.0;
    float x = mod(pos.x + t, so);
    float y = mod(pos.y + t, so*2.0);
    float d1 = mod( distance( vec2(x,y), vec2(so*0.45,so*1.05) ) + t*0.5, 0.05) * 3.0 + pos.x * 0.5;
    float d2 = mod( distance( vec2(x,y), vec2(so*0.55,so*0.95) ) + t*0.5, 0.015) * 3.0;

    if ((x-0.03 < sd) && (y-0.03 < sd*2.0))
    if ((x < sd) && (y < sd*2.0))
        col = vec3(0.2, 0.6, mix(d1, d2, 0.8) );
    else
        col = vec3(0.72, 0.25, pos.y * 0.06 + 0.3);


    float l = length(mod(t* 0.1 + col * distance(pos,vec2(pos.y,0.0)) ,0.02)*27.5); 

    if ((pos.y>0.1) && (pos.y < 0.9))
        gl_FragColor = vec4( l,l,l, 1.0 );
    else
        gl_FragColor = vec4( 0.9,0.9,0.9, 1.0);
}
</script>

<script type="text/javascript">

var DemoModel = function()
{
    this._program = new GLSL.Program;
    // Map from "name_type" to previous GLSL value.
    this._previousInputs = {};

    GLSL.Shader.addEventListener(GLSL.Shader.Event.ExecutableChanged, this._shaderExecutableChanged, this);
    this._program.addEventListener(GLSL.Program.Event.ShaderChanged, this._shaderSourceChanged, this);

    this._resetEnvironment();
};

DemoModel.Event = {
    ShaderChanged: "demo-model-shader-changed",
    InputsChanged: "demo-model-inputs-changed",
    ResultChanged: "demo-model-result-changed",
    Error: "demo-model-error"
};

DemoModel.prototype = {
    __proto__: GLSL.Object.prototype,
    constructor: DemoModel,

    // Public

    shaderWithType: function(shaderType)
    {
        return this._program.shaderWithType(shaderType);
    },

    getSuggestedVariableValue: function(variable)
    {
        if (!variable || variable.readOnly)
            return null;

        var key = [variable.name, variable.type].join("_");
        if (key in this._previousInputs)
            return this._previousInputs[key];

        return null;
    },

    setVariableValue: function(variable, value)
    {
        this.env.set(variable.name, value);
        var key = [variable.name, variable.type].join("_");
        this._previousInputs[key] = value;
        this.dispatchEventToListeners(DemoModel.Event.InputsChanged, {variable: variable});

        this._runShaders();
    },

    // Private

    _resetEnvironment: function()
    {
        var model = this;

        function setDefaultValue(env, variable) {
            var value = model.getSuggestedVariableValue(variable) || 0.0;
            if (!value) {
                switch (variable.type) {
                case "bool": value = true; break;
                case "vec2": value = GLSL.Runtime.Vec2(0, 0); break;
                case "vec3": value = GLSL.Runtime.Vec3(0, 0, 0); break;
                case "vec4": value = GLSL.Runtime.Vec4(0, 0, 0, 0); break;
                case "mat2": value = GLSL.Runtime.Mat2(0, 0,
                                                       0 ,0); break;
                case "mat3": value = GLSL.Runtime.Mat3(0, 0, 0,
                                                       0, 0, 0,
                                                       0, 0, 0); break;
                case "mat4": value = GLSL.Runtime.Mat4(0, 0, 0, 0,
                                                       0, 0, 0, 0,
                                                       0, 0, 0, 0,
                                                       0, 0, 0, 0); break;
                }
            }

            env.set(variable.name, value);
        }

        function setDefaultValuesForShader(shader, env) {
            if (!shader)
                return;

            shader.uniforms.map(setDefaultValue.bind(null, env));
            shader.attributes.map(setDefaultValue.bind(null, env));
            if (shader.type === GLSL.Shader.Type.Fragment)
                shader.varyings.map(setDefaultValue.bind(null, env));
        }

        this.env = new GLSL.Environment;
        setDefaultValuesForShader(this.shaderWithType(GLSL.Shader.Type.Vertex), this.env);
        setDefaultValuesForShader(this.shaderWithType(GLSL.Shader.Type.Fragment), this.env);

    },

    _runShaders: function()
    {
        function invokeShaderOrFail(shader) {
            if (!shader)
                return true;

            if (shader.executable.error) {
                var errorType = (shader.type === GLSL.Shader.Type.Vertex) ? GLSL.Error.Type.VertexShaderTranslation : GLSL.Error.Type.FragmentShaderTranslation;
                var data = {type: errorType, message: shader.executable.error};
                this.dispatchEventToListeners(DemoModel.Event.Error, data);
                return false;
            }

            try {
                shader.executable.code.call(null, GLSL, this.env);
            } catch (e) {
                var errorType = (shader.type === GLSL.Shader.Type.Vertex) ? GLSL.Error.Type.VertexShaderExecution : GLSL.Error.Type.FragmentShaderExecution;
                this.dispatchEventToListeners(DemoModel.Event.Error, {type: errorType, message: e.message});
                return false;
            }

            return true;
        }

        var vertexShader = this.shaderWithType(GLSL.Shader.Type.Vertex);
        if (!invokeShaderOrFail.call(this, vertexShader))
            return;

        var fragmentShader = this.shaderWithType(GLSL.Shader.Type.Fragment);
        if (!invokeShaderOrFail.call(this, fragmentShader))
            return;

        this.dispatchEventToListeners(DemoModel.Event.ResultChanged);
    },

    _shaderExecutableChanged: function(event)
    {
        this._runShaders();
    },

    _shaderSourceChanged: function(event)
    {
        this._resetEnvironment();
        this._runShaders();
    }
};

var model = null;

window.addEventListener("load", function initEditors() {
    model = new DemoModel();

    var leftSide = document.getElementById("left-side");
    var rightSide = document.getElementById("right-side");

    var suggestedVariableValueCallback = DemoModel.prototype.getSuggestedVariableValue.bind(model);

    var variableList = new VariableListView(null, suggestedVariableValueCallback);
    leftSide.appendChild(variableList.element);
    var editor = new EditorView(model._program);
    leftSide.appendChild(editor.element);

    var resultsTop = new DebugView(model, "top");
    rightSide.appendChild(resultsTop.element);
    var resultsBottom = new DebugView(model, "bottom");
    rightSide.appendChild(resultsBottom.element);

    function variableValueInputChanged(event) {
        var variable = event.data.variable;
        model.setVariableValue(variable, event.data.value);
    }

    function recreateVariableList() {
        variableList.removeEventListener(VariableListView.Event.VariableValueChanged, variableValueInputChanged);
        var newList = new VariableListView(model.shaderWithType(editor.activeShaderType), suggestedVariableValueCallback);
        newList.addEventListener(VariableListView.Event.VariableValueChanged, variableValueInputChanged);

        leftSide.replaceChild(newList.element, variableList.element);
        variableList = newList;
    }

    editor.addEventListener(EditorView.Event.ShaderTypeChanged, recreateVariableList);
    model._program.addEventListener(GLSL.Program.Event.ShaderChanged, recreateVariableList);

    model.addEventListener(DemoModel.Event.ResultChanged, function refreshViews(event) {
        variableList.populateResults(model.env);
        resultsTop.refresh();
        resultsBottom.refresh();
    });

    model.addEventListener(DemoModel.Event.Error, function displayError(event) {
        var errorType = event.data.type;
        if (errorType === GLSL.Error.Type.VertexShaderTranslation || GLSL.Error.Type.VertexShaderExecution) {
            resultsBottom.activeShaderType = GLSL.Shader.Type.Vertex;
            resultsBottom.activeOutputType = "codegen";
        }

        if (errorType === GLSL.Error.Type.FragmentShaderTranslation || GLSL.Error.Type.FragmentShaderExecution) {
            resultsBottom.activeShaderType = GLSL.Shader.Type.Fragment;
            resultsBottom.activeOutputType = "codegen";
        }

        resultsTop.showErrorMessage(errorType, event.data.message);
    });

    window.addEventListener("resize", editor.autosizeHeight.bind(editor));

    model._program.updateShaderWithType(GLSL.Shader.Type.Vertex, document.getElementById("sample-vertex-shader").textContent);
    model._program.updateShaderWithType(GLSL.Shader.Type.Fragment, document.getElementById("sample-fragment-shader").textContent);
    editor.refresh();

    // Change these defaults if you want to start somewhere else.
    editor.activeShaderType = GLSL.Shader.Type.Vertex;

    resultsTop.activeShaderType = GLSL.Shader.Type.Vertex;
    resultsTop.activeOutputType = "codegen";

    resultsBottom.activeShaderType = GLSL.Shader.Type.Vertex;
    resultsBottom.activeOutputType = "ast";
});

</script>

</body>
</html>
