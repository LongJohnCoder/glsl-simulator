<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Glsl-simulator : A simulator for OpenGL ES 1.0 Shader Language written in JavaScript.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Glsl-simulator</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/burg/glsl-simulator">View on GitHub</a>

          <h1 id="project_title">Glsl-simulator</h1>
          <h2 id="project_tagline">A simulator for OpenGL ES 1.0 Shader Language written in JavaScript.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/burg/glsl-simulator/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/burg/glsl-simulator/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="id-problem" class="anchor" href="#id-problem" aria-hidden="true"><span class="octicon octicon-link"></span></a>Motivation and Problem</h3>

<p>The introduction of WebGL finally let programmers create and share shaders, textures,
models, and games in a portable way on the web. However, tools for inspecting,
understanding, and debugging WebGL content lag far behind the capabilities of other web
content. In particular, shaders are a black box: all we can find out with current tools is what
inputs go in (textures, varying and uniforms, coordinates) and what outputs come out (color,
vertices). Thus, writing and debugging shaders is often perceived as an arcane and frustrating
task driven by making blind guesses, tweaking the shader source, and trying again.</p>

<p>Shaders should be the easiest part of the graphics pipeline to debug and understand. If a
developer wants to know how a pixel was modified by a shader, she should be able to click on
the output pixel for a specific frame and see how it is arrived at. It should be straightforward to
see how textures are sampled, view shader uniforms and interpolated inputs, and inspect a
variable’s runtime values at any program point. She should be able to step through execution
to understand control flow. Lastly, it should be simple for her to visualize intermediate runtime
states for specific pixels, all pixels within a frames, or over time.</p>

<h3>
<a id="id-approach" class="anchor" href="#id-approach" aria-hidden="true"><span class="octicon octicon-link"></span></a>Approach</h3>

<p>We propose to design and implement a GLSL shader simulator as the key technology to
enable these debugging tools for WebGL. Since shader programs run on the GPU, there is no
way to pause execution or inspect runtime values in the conventional sense. To obtain this
information, we can instead simulate the shader’s execution with a specific set of inputs
(exploiting the determinism of shader programs). Runtime data that’s needed by debugging
affordances can then be regenerated on­demand by running the shader simulator with the
necessary inputs. These inputs (uniforms, varying, gl_Position, textures, etc.) are easy to
instrument in modern WebGL implementations. Since shaders are short and must run quickly
on hardware, this runtime data can be produced with low latency during debugging sessions.</p>

<h3>
<a id="id-related" class="anchor" href="#id-related" aria-hidden="true"><span class="octicon octicon-link"></span></a>Related Work</h3>

<p>The most common debugging method is “printf­style” debugging, where the state to
inspect is encoded as a color and assigned to gl_FragColor, then later visualized. This
has serious limitations, such as supporting only a vec3 of debug output per shader.
However, it can run on the GPU and is portable.</p>

<p>Mesa is the original software­based graphics stack (C/C++). It has a full parser,
optimizer, and software interpreter for GLSL and ARB assembly code.</p>

<p>Apple OpenGL Shader Builder, FX Composer, RenderMonkey, and Firefox’s shader
editor allow uniforms, textures, etc to be edited in real­time, but can’t inspect internal
shader state.</p>

<p>The paper “Step­through debugging of GLSL shaders”
(http://www.cdm.depaul.edu/SoC/research/Documents/TechnicalReports/2006/TR06­0
15.pdf) proposes to extend printf debugging for two purposes: to simulate stepping
through a shader for the full screen, and stepping through control flow for a specific
pixel. They use rewriting techniques to save intermediate values, assign to
gl_FragColor, then return early.</p>

<p>NVIDIA nSight and AMD ShaderAnalyzer offer a full stepping debugger for shaders,
implemented using proprietary hooks in their drivers to get data.</p>

<p>glslDevil (now http://glsl­debugger.github.io/) uses a similar “printf­like” instrumentation
technique to dump intermediate shader runtime values by running the modified shader
on the GPU. It cannot do stepping, however. (slides:
http://www.graphicshardware.org/previous/www_2007/presentations/strengert­opengld
ebugger­gh07.pdf)</p>


<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

Brian Burg (<a href="https://github.com/burg">@burg</a>)
<br/>
Sophia Wang (<a href="https://github.com/xiaosophiawang">@xiaosophiawang</a>)

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Glsl-simulator maintained by <a href="https://github.com/burg">burg</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
